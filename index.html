<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MNIST Digit Predictor</title>
    <style>
      #canvas {
        border: 2px solid black;
        margin-top: 10px;
      }
    </style>
  </head>
  <body>
    <h1>MNIST Digit Predictor</h1>
    <canvas id="canvas" width="350" height="350"></canvas>
    <br/>
    <h2>Temp Canvas</h2>
    <canvas id="tempCanvas" width="28" height="28"></canvas>

    <br/>
    <h2>Probabilities for each digit:</h2>
<table id="probabilityTable">
  <thead>
    <tr>
      <th>Digit</th>
      <th>Probability</th>
    </tr>
  </thead>
  <tbody>
  </tbody>
</table>
    
    <h2>Prediction: <span id="prediction"></span></h2>
    <button id="clearButton">Clear</button>

    <!-- Include the ONNX Runtime Web library -->
    <script src="https://cdn.jsdelivr.net/npm/onnxruntime-web/dist/ort.min.js"></script>
    <script>
      // Canvas setup for drawing
      const canvas = document.getElementById('canvas');
      const ctx = canvas.getContext('2d');

      ctx.fillStyle = "black";
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.lineWidth = 30;
      ctx.lineJoin = 'round';
      ctx.lineCap = 'round';
      ctx.strokeStyle = 'white';
      
      let isDrawing = false;

      canvas.onmousedown = (e) => {
        isDrawing = true;
        ctx.beginPath();
        ctx.moveTo(e.offsetX, e.offsetY);
      };

      canvas.onmousemove = (e) => {
        if (isDrawing) {
          ctx.lineTo(e.offsetX, e.offsetY);
          ctx.stroke();
        }
      };

     
      // Function to clear the canvas
      const clearCanvas = () => {
        ctx.fillStyle = "black";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        document.getElementById('prediction').textContent = "";
      };

      // Get image data from the canvas
      const getImgData = () => {
  // Create a temporary canvas to draw a downscaled image.
  const tempCtx = document.getElementById('tempCanvas').getContext('2d');
   

  tempCanvas.width = 28;
  tempCanvas.height = 28;
  tempCtx.filter = 'grayscale(1)';
  // Draw the original canvas image to the temporary canvas, effectively resizing it.
  tempCtx.drawImage(canvas, 0, 0, 28, 28);

  // Now, extract the image data from the temporary canvas.
  const imageData = tempCtx.getImageData(0, 0, 28, 28);

  const data = [];
  for (let i = 0; i < imageData.data.length; i += 4) {
    const grayscale = imageData.data[i];
    data.push((grayscale) / 255); // Inverted grayscale values
  }


  // Standardization
  const mean = 0.1307;
  const std = 0.3081;
  const standardizedData = data.map(value => (value - mean) / std);

  return standardizedData; // This returns the standardized 1D array suitable for the model input.
};



      const softmax = (data) => {
        // Your softmax function remains unchanged
        const exps = data.map((value) => Math.exp(value));
        const sumExps = exps.reduce((acc, val) => acc + val, 0);
        return exps.map((exp) => exp / sumExps);
      };

      const main = async () => {
  // Create an ONNX session with the model.
  const session = await ort.InferenceSession.create('./mnist_model.onnx');
  
  document.getElementById('clearButton').onclick = async () => {
    clearCanvas();

  };
  const predict = async () => {
    // Get the image data (28x28) from your canvas or image element.
    const data = getImgData(); // This function should return a Float32Array representing the image.

    // Create a tensor with the image data.
    const inputTensor = new ort.Tensor('float32', data, [1, 1, 28, 28]);

    // Run the model with the tensor as input.
    const outputMap = await session.run({ input: inputTensor });

    // Instead of using outputMap.values(), we directly access the output tensor by key.
    // This assumes 'output' is the name of the output layer. Adjust as necessary for your model.
    const outputTensor = outputMap.output;

    // Retrieve the actual data from the tensor.
    const outputData = outputTensor.data;

      // Process the output data here (apply softmax if necessary).
  const probabilities = softmax(Array.from(outputData));

// Find the predicted digit: the index of the highest probability.
const prediction = probabilities.indexOf(Math.max(...probabilities));

// Update the probabilities display for each digit.
const probabilityTable = document.getElementById('probabilityTable').getElementsByTagName('tbody')[0];
probabilityTable.innerHTML = ""; // Clear the previous probabilities

probabilities.forEach((probability, index) => {
  // Create a new row and two cells (for the digit and its probability).
  const newRow = probabilityTable.insertRow();
  const digitCell = newRow.insertCell(0);
  const probabilityCell = newRow.insertCell(1);

  // Set the text of the cells.
  digitCell.textContent = index;
  probabilityCell.textContent = probability.toFixed(4); // Display probability up to 4 decimal places
});
    
document.getElementById('prediction').textContent = prediction;
    
  };

  canvas.onmouseup = () => {
        isDrawing = false;
        predict();
      };



};


      main();
    </script>
  </body>
</html>
